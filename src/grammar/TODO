
* Let's give the world a fold-left language construct that one can actually read and
  remember to write.

* match expressions do not seem to be handled by the Java to Scala translator

* Maybe a toJson1 and toJson2 in every class

* Documentation

* Simpler way to write JSON transformers:

  Original version:
  
  override def toJson1 = {
    val typedecl = new JSONObject()
    val params = new JSONArray()
    typedecl.put("ident", ident)
    for (typeParam <- typeParams) params.put(typeParam.toJson)
    typedecl.put("type", "TypeDecl")
    typedecl.put("params", params)
    if (ty.nonEmpty) typedecl.put("ty", ty.get.toJson)
    else typedecl
  }

  Simpler version:

  override def toJson1 = {
    val typedecl = newJSONObject("TypeDecl")
    typedecl.put("ident", ident)
    typedecl.array("params",typeParams)
    typedecl.optput("ty",ty)
  }

* It does not seem to handle type declarations correctly in the translation
from a Java tree to a Scala tree.



---------

Semicolon: 

- also, in pure functions it looks strange, like a defintion that could look like 
  this:
 
    def f(x:Int) = x + 1

  or even:

   def f x = x + 1

  becomes:

    def f(x:Int):Int { x + 1; }

Function return types: it looks wordy in the case of Void. I would aAvoid it.

Comments: well, --- is interesting since it can be used to frame a text (if done right) 
as in:

  -----------------------
  This code is brilliant.
  and I stick to it.
  Period.
  -----------------------

  def f(x:Int):Int {x+1}

The problem is if a comment stretches over many many lines, then it becomes
non-obvious what is a comment and what is not. Could be like this:

  =======================
  This code is brilliant.
  and I stick to it.
  Period.
  -----------------------

  def f(x:Int):Int {x+1}

and as in:

=== 
This is a comment stretching
several lines.
---

create is a long word. new is standard after all.

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
------------

Simpler rules for bindings and patterns

real, int, nat, nat1 (see PVS)

--------------
LESS PRIORITY:
--------------

clean up bindings and typings and patterns

anonymous class extension instead of class value parameters (Brad) ?

variant types (enum) case statements, quote/symbol types

abbreviations:
  function definitions divided into signature and close-by-axiom without quantification 

iterators: instead of built in notation

what is an instantiation?

infix operators versus "methods" 
  for example: dom, rng, restriction

symbols:
  >< instead of *
  /\ and \/ instead of & and |
  also && and ||?
  . instead of :-
  [ ] for list and map indexing
  +> or |-> instead of -> for map pairs
  Int list, Int-list, listof Int
  A -m-> B, map A to B, A +> B
  <-, in set, not in set
  dinter, dunion
  <> for inequality
  
partial functions  
  
hiding

overloading

infix operators

distributed union and intersection

modifiers? can it be handled by interfaces?

axiom global quantification

distinction between finite and infinite sets

type parameterized functions (polymorphism)

choice, let x: Int :- x > 0 in exp
  problem is that this makes expression evaluation
  non-deterministic

union types

optional type: [T] or Option[T]

-- DISCUSSED: --

emphasize type inference (Klaus and Brad)

types before as in Java or after (Klaus: after, Brad: before)

removed keyword 'class' (Brad)

introduced and/or instread of &&/|| (Brad)

do we need constructors?

introduced constraintName {...} instead of [constraintName] ... (Brad)

added semicolon as optional (Brad)

how do we define functions (Brad):
  f(x:Int) {x+1} 
    or
  f(x:Int) = x + 1

We now use <..> instead of [..] (Brad)

is cartesian product needed? (Brad)
  In Scala there is a type called Product but there is special syntax
  for cartesian product anyway. It seems very fundamental. Things get clumsy
  to write without it.

do we need sorts, aren't they just types (Brad), they are now deleted

------------------
Grammars Explored:
------------------

Programming languages:

[1] ML
[ ] Fortress
[ ] Scala
[ ] SETL
[ ] Haskell

Specification languages:

[1] RSL
[1] Z
[1] VDM
[1] VDM++
[ ] B/Event-B
[ ] Alloy
[1] PVS

UML-based languages:

[ ] OCL
[ ] OWL
[ ] Brad's dot-notation wiki page