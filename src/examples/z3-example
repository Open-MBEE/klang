
===================
VERIFICATION TASKS:
===================

-  that function applications satisfy post conditions plus requirements
   under assumption of preconditions and requirements

- that the function definitions are satisfiable

- that the requirements are satisfiable


=============
EXAMPLE IN K:
=============

class A {
  a : Int

  fun incr(x:Int):Int {
    a + x
  }
}

class MyInt {
  x : Int
  y : Int

  fun abs : Int 
    post $result >= 0
  {
    if x < 0 -x else x
  }

  fun checkSquare: Bool {
    x * x = y
  }

  req checkSquare()

  fun f(x:Int):A {
    A(a=x)
  }

  req forall x : Int . f(x).a = x

  req f(x).a = x

  type SillyTuple = Int * Bool

  fun sillyRep(x:Int) : SillyTuple {
    Tuple(if x < 0 then -x else x,x>=0)
  }

  fun sillyNeg(t : SillyTuple): SillyTuple {
    Tuple(x#1,!x#2)
  }

  req sillyNeg(sillyRep(-1))#1 = 1

  req sillyNeg(sillyRep(-1))#2 = false

}

mi : MyInt = MyInt(x=1,y=2)


==============
EXAMPLE IN Z3:
==============

(declare-datatypes () ((A (mkA (a Int)))))

(define-fun A.incr ((ma A) (x Int)) Int
  (+ (a ma) x)
)

(declare-datatypes () ((MyInt (mkMyInt (x Int) (y Int)))))

(declare-datatypes (T1 T2) ((Tuple2 (mkTuple2 (fst T1) (snd T2)))))
(declare-datatypes (T1 T2 T3) ((Tuple3 (mkTuple3 (fst T1) (snd T2) (trd T3)))))


(define-fun MyInt.abs ((mi MyInt)) Int
  (ite (< (x mi) 0) (- (x mi)) (x mi))
)

(define-fun MyInt.checkSquare ((mi MyInt)) Bool
  (= (* (x mi) (x mi)) (y mi))
)

(define-fun MyInt.f((x Int)) A
  (mkA x)
)

(declare-const intInit Int)

(define-fun newMyInt ((k Int)) MyInt
  (mkMyInt intInit intInit)
)

(define-fun MyInt.sillyRep ((x Int)) (Tuple2 Int Bool) 
  (mkTuple2 (ite (< x 0) (- x) x) (>= x 0))
)

(define-fun MyInt.sillyNeg ((t (Tuple2 Int Bool))) (Tuple2 Int Bool) 
   (mkTuple2 (fst t) (! (snd t))) 
)  
(assert (forall ((mi1 MyInt)) (>= (MyInt.abs mi1) 0)))

(assert (exists ((mi2 MyInt)) (MyInt.checkSquare mi2)))

(assert (forall ((x Int)) (= (a (MyInt.f x)) x)))

(declare-const mi0 MyInt)
(assert (MyInt.checkSquare mi0))

(assert (= (fst (MyInt.sillyNeg (MyInt.sillyRep (- 1)))) 1))


(assert (= (snd (MyInt.sillyNeg (MyInt.sillyRep (- 1)))) false))

(check-sat)
(get-model)


