
\section{Translating K to SMT-LIB}

In this section we illustrate the translation from K to the SMT-
LIB input language. SMT-LIB \cite{smt-lib} is the standard 
``satisfiability modulo theories library'' for SMT solvers. The 
standard is used by numerous SMT solvers, allowing comparison 
between systems (for example in competitions). 
In addition, it allows systems generating SMT-LIB 
formulas to target any SMT solver processing this standard. In our 
case we  use the Z3 SMT solver to process the generated formulas, 
but we anticipate to target other solvers as well in future work.

\subsection{The Source K Model}

\begin{figure}
\centering
\begin{tabular}{c}
\hline \\
\lstinputlisting{examples/spacecraft.k} \\ \\
\hline
\end{tabular}
\caption{A simple \Klang{} model of a spacecraft}
\label{fig:spacecraftSmt}
\end{figure}

The translator currently covers a subset of the K language
corresponding to the model shown in Figure 
\ref{fig:spacecraftSmt}. The example illustrates the features
of K that have been used by engineers at JPL until the time of 
writing. The emphasis of these models is on {\em structure}
of artifacts and {\em scheduling} of events. The model models a 
spacecraft. The class \code{Object} is meant to represent entities 
that have weight. Instruments, and its radio sub-classes, as well
as the the spacecraft itself are objects, inheriting from this 
class. The class \code{Instrument} defines a \code{power} level 
consumed. Requirements in the form of Boolean constraints are 
imposed on \code{power} and \code{weight}. The 
\code{SpaceCraft} class makes instances of instruments,
defines a combined sum \code{instrumentsWeight} and a
constraint on it with additional requirements. The elements of
the model discussed above are so-called {\em structural} elements,
what one would normally see in a class diagram.

The spacecraft in addition contains a system manager, representing
the software on board. For the purpose of illustration, the system manager is defined as a small {\em scheduler} of three events: 
a \code{bootUp} event, re-booting the flight software computer, a \code{initMem} event, initializing the computer memory, and a 
\code{takePicture} event, taking a picture. An event is a constant
of the \code{Event} class, which defines an event as having a start time and and end time appearing after the start time. In addition, the \code{Event} class defines a function \code{after},
which as argument takes another event `\code{e}', 
and returns true if the event (this) occurs after `\code{e}'.
The \code{after} function is part of Allen logic 
\cite{allen-logic-84} used by the planning and scheduling community. 
%
Finally, the model contains an instance \code{ShRaan} of type
\code{SpaceCraft}.

Given the spacecraft model, the general proof-theoretic
problem we want an answer to is whether our classes are logically consistent. That is, whether the constraints of each class are consistent (do not evaluate to {\em false} such as for example is
the case with: `$x < 0 \wedge x > 0$'). From a semantics point of view, it means that for each class there exists at least one instance (object) of that class that satisfies the constraints. 
The specific satisfiability problem that perhaps interests a
user most is whether there is an instance of the \code{SpaceCraft} class, which satisfies all the constraints of that class and the classes it refers to.



\subsection{The Translation to SMT-LIB}

The SMT-LIB input language (from here on referred to as SMT-LIB)
is essentially a textual language for typed first order predicate logic plus various theories, including for example arithmetic,
unintepreted functions, and arrays. The syntax is LISP-like,
meaning for example that function calls such as $f(42,false)$
have the form $(f\ 42\ false)$. For the 44 line K model in Figure 
\ref{fig:spacecraftSmt}, the translator generates 333 lines of 
uncommented SMT-LIB code  (additional comments are generated to 
make the output easier for 
humans to read). We shall highlight subsets from each class of
formulas generated. Our main challenge in translating K to SMT-LIB 
is how to translate classes while supporting (multiple) {\em 
inheritance} and {\em recursive} references between 
classes. This will be illustrated in the following. 

\subsubsection{Classes, objects, and the heap}

Let's first translate a simple class, such as class \code{Object}.
We have chosen to translate classes to the SMT-LIB concept of {\em 
datatypes}. A datatype in SMT-LIB corresponds to the classical 
notion of an algebraic datatype: a named record, with a constructor 
function  that when applied to a sequence of values generates a 
value of the  datatype, while the values can be retrieved using the 
selectors.  The class \code{Object} can be  represented in SMT-LIB 
as:

\lstset{language=SMT}

\begin{center}
\begin{tabular}{c}
\begin{lstlisting}
(declare-datatypes () ((Object 
  (mk-Object (weight Int)))))
\end{lstlisting}
\end{tabular}
\end{center}

This declaration declares the datatype \code{Object}, the 
constructor \code{mk-Object}, which can be called on a value 
\code{w} of type \code{Int} as follows: \code{(mk-Object w)}, to 
produce a value in type \code{Object}. Reversely, given a value 
\code{o} in type \code{Object}, we can retrieve the weight by 
applying the selector function \code{weight} to \code{o} as 
follows: \code{(weight o)}.

Consider now the following schematic example of two
mutually recursive classes, a situation often occurring in SysML modeling (relationships between two classes) as well as in programming (i.e. linked lists):

\lstset{language=K}

\begin{center}
\begin{tabular}{c}
\begin{lstlisting}
class A {
  b : B
}

class B {
  a : A
}
\end{lstlisting}
\end{tabular}
\end{center}

The following translation of this model to the SMT-LIB datatypes \code{A} and \code{B} is {\bf not} well-founded since it contains a recursion between \code{A} and \code{B} (it is illegal SMT-LIB).

\lstset{language=SMT}

\begin{center}
\begin{tabular}{c}
\begin{lstlisting}
(declare-datatypes () (
  (A (mk-A (b B)))
  (B (mk-B (a A)))
))
\end{lstlisting}
\end{tabular}
\end{center}

The conclusion is that we need to operate with references to 
objects rather than objects directly, exactly as a runtime system 
for an object-oriented programming language would. In other words, 
we need a {\em heap} mapping references to objects. For this 
purpose must define the type of references, which are just 
integers:

\begin{center}
\begin{tabular}{c}
\begin{lstlisting}
(define-sort Ref () Int)
\end{lstlisting}
\end{tabular}
\end{center}

We can now define the datatypes by letting properties having a 
class as type in K have type \code{Ref} in SMT-LIB, as in the 
following definition of the \code{SpaceCraft} datatype.

\begin{center}
\begin{tabular}{c}
\begin{lstlisting}  
(declare-datatypes () ((SpaceCraft 
  (mk-SpaceCraft (weight Int)
                 (instrumentsWeight Real)
                 (radio Ref)
                 (camera Ref)
                 (software Ref)))))
\end{lstlisting}
\end{tabular}
\end{center}

Observe furthermore how the fact that \code{SpaceCraft} inherits
from \code{Object} is modeled by the inclusion of the \code{weight}
field from \code{Object}. Inheritance is simply modeled by
property inclusion in this manner. 

In order to define a heap, we need a datatype that represents all 
the objects. The following datatype \code{Any} represents all the 
datatypes for the individual classes, by lifting them to this single type. The type \code{Any} corresponds to Java's type \code{Object}.

\begin{center}
\begin{tabular}{c}
\begin{lstlisting}
(declare-datatypes () ((Any
  (lift-Object (sel-Object Object))
  (lift-Instrument (sel-Instrument Instrument))
  (lift-SpaceCraft (sel-SpaceCraft SpaceCraft))
  ...
  null))
)
\end{lstlisting}
\end{tabular}
\end{center}

Now we can define the heap as a mapping (an array) from
references of type \code{Ref} to \code{Any}. 

\begin{center}
\begin{tabular}{c}
\begin{lstlisting}
(declare-const heap (Array Ref Any))
\end{lstlisting}
\end{tabular}
\end{center}

\subsubsection{Accessing the heap}

We first define a function \code{deref}, which when applied to a reference returns the \code{Any} object at that entry:

\begin{center}
\begin{tabular}{c}
\begin{lstlisting}
(define-fun deref ((ref Ref)) Any
  (select heap ref)
)
\end{lstlisting}
\end{tabular}
\end{center}

With this function we are now ready to define function, which
can test what kind of object is at a certain location in the heap,
as well as retrieve that object. The following functions perform
these two tasks for the case of the \code{Instrument} objects
(for each datatype constructor \code{C}, SMT-LIB generates
a \code{is-C} function that can determine whether an object is
constructed with the constructor):

\begin{center}
\begin{tabular}{c}
\begin{lstlisting}
(define-fun deref-is-Instrument ((this Ref)) Bool
  (is-lift-Instrument (deref this))
)

(define-fun deref-Instrument ((this Ref)) Instrument
  (sel-Instrument (deref this))
)
\end{lstlisting}
\end{tabular}
\end{center}

Recall that classes can contain properties of types that are
classes. For example the \code{SpaceCraft} class contains a 
property \code{radio} of type \code{Instrument}. In an 
object-oriented language like K with inheritance, 
such a property can denote any object that is of type that either 
is equal to, or sub-classes \code{Instrument}. In order to 
formulate invariants on objects of class \code{SpaceCraft}, 
we need to be able to determine whether a \code{radio} object 
is equal to, or sub-classes \code{Instrument}. This task is performed by the following function, the body of which is a disjunction between the three alternatives.

\begin{center}
\begin{tabular}{c}
\begin{lstlisting}
(define-fun deref-isa-Instrument ((this Ref)) Bool
  (or
    (deref-is-Instrument this)
    (deref-is-SimpleRadio this)
    (deref-is-SmartRadio this)
  )
)
\end{lstlisting}
\end{tabular}
\end{center}

\subsubsection{Getters of properties in classes}

Functions and requirements access properties. An example is
the expression \code{weight > 0} in class \code{Instrument}.
These accesses are wrapped into {\em getter} functions. As an 
example, the \code{weight} property of the class \code{Instrument} 
can be accessed with a call of the following function, named 
\code{Instrument!weight} (SMT-LIB allows symbols such as `\code{!}' 
in names, to be discussed futher below), on a reference that is 
assumed to refer to an \code{Instrument} object.

\begin{center}
\begin{tabular}{c}
\begin{lstlisting}
(define-fun Instrument!weight ((this Ref)) Int
  (weight (deref-Instrument this))
)
\end{lstlisting}
\end{tabular}
\end{center}

The above definition assumes that the \code{this} reference denotes
an \code{Instrument} object, and not an object of any sub-class on 
\code{Instrument}, hence the `\code{!}' symbol (for {\em exact! 
class}) in the name. 
This is sufficient when checking satisfiability 
of the class \code{Instrument} class itself. However, when checking 
the satisfiability of for example the \code{SpaceCraft} class, 
which {\em contains} a property of type \code{Instrument}, as for 
example \code{radio : Instrument}, we have to assume that 
\code{radio} in addition potentially can refer to any object of a 
class that sub-classes \code{Instrument}, which in this case is 
either \code{SimpleRadio} or \code{SmartRadio}. This is achieved 
with the following alternative getter function, named 
\code{Instrument.weight}, for the 
\code{weight} property of the class \code{Instrument}:

\begin{center}
\begin{tabular}{c}
\begin{lstlisting}
(define-fun Instrument.weight ((this Ref)) Int
  (ite (deref-is-Instrument this)         ; if
    (weight (deref-Instrument this))      ; then
    (ite (deref-is-SimpleRadio this)      ; else if
      (weight (deref-SimpleRadio this))   ; then
      (weight (deref-SmartRadio this))))) ; else
\end{lstlisting}
\end{tabular}
\end{center}

Each line in the body ends with a comment after the comment symbol `\code{;}' explaining the structure of the LISP version of 
`${\bf if}\ e_1\ {\bf then}\ e_2\ {\bf else}\ e_3$', which is 
`$({\bf ite}\ e_1\ e_2\ e_3)$'.

The reason for not just using the latter more general function \code{Instrument.weight} for all accesses to the \code{weight} property is that it makes it harder to the SMT solvers. Event moderately sized expressions with several accesses to variables
become unsolvable in reasonable time in the presence of such conditional expressions. This is why the former exact version \code{Instrument!weight} was introduced for those validity checks
where we can ignore sub-classing.

\subsubsection{Methods}

Methods functions are translated directly to SMT-LIB functions.
Each function is translated in two versions, corresponding to
the two versions of the getter functions, and named using
respectively \code{className!methodName} and 
\code{className.methodName}, to suggest which getter functions are 
called inside the method, again depending on the calling context
(does \code{this} refer to the exact class or potentially
a sub-class). As an example the following is the translation of the 
\code{after} method in the class \code{Event}:

\begin{center}
\begin{tabular}{c}
\begin{lstlisting}
(define-fun Event.after ((this Ref)(e Ref)) Bool
  (>= (Event.start this)  (Event.end e))
)

(define-fun Event!after ((this Ref)(e Ref)) Bool
  (>= (Event!start this)  (Event.end e))
)
\end{lstlisting}
\end{tabular}
\end{center}

The first parameter is a reference (named \code{this})
of type \code{Ref}. The \code{this} reference is meant to 
refer to the object upon which the method is called. Consider for example a call like: \code{takePicture.after(initMem)} in line 29 of Figure
\ref{fig:spacecraftSmt}. Here \code{takePicture} denotes a reference to which the parameter \code{this} is bound.
The second parameter is the user-provided parameter.

\subsubsection{Invariants and assertions}

We are finally able to present how class invariants are generated, 
which validate the satisfiability of our classes, as well as how 
these invariants are asserted. The invariant for a class is
generated as a function that as argument takes a \code{this}
reference to an object of that class. Let's take the example of the
\code{SystemManager} class. The generated invariant is the 
following:

\begin{center}
\begin{tabular}{c}
\begin{lstlisting}
(define-fun SystemManager.inv ((this Ref)) Bool
  (and
    (deref-isa-Event (SystemManager!bootUp this))
    (deref-isa-Event (SystemManager!initMem this))
    (deref-isa-Event (SystemManager!takePicture this))
    (and 
      (Event.after 
        (SystemManager!takePicture this)  
        (SystemManager!initMem this)) 
      (Event.after 
        (SystemManager!takePicture this)  
        (SystemManager!bootUp this))
    )
  )
)
\end{lstlisting}
\end{tabular}
\end{center}

The body of this function is a conjunction of the conditions
that have to hold for the \code{SystemManager} object referred to
by \code{this}. There are four such, three for the property
definitions in lines 26-28 in Figure \ref{fig:spacecraftSmt},
and one for the requirement in line 29. Each of the property definitions results in a condition that 

\hline

\begin{center}
\begin{tabular}{c}
\begin{lstlisting}
(assert (forall ((this Ref))
  (=> (deref-is-SystemManager this) (SystemManager.inv this))
))
\end{lstlisting}
\end{tabular}
\end{center}

\hline

\begin{center}
\begin{tabular}{c}
\begin{lstlisting}
(assert (exists ((instanceOfInstrument Ref)) 
  (deref-is-Instrument instanceOfInstrument)))
...
\end{lstlisting}
\end{tabular}
\end{center}

\hline

\begin{figure}
\VerbatimInput{examples/spacecraftOutput.k}
\caption{Output of the K toolchain for the spacecraft example.}
\label{fig:shapes}
\end{figure}

\lstset{language=K}
