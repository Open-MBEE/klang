
\section{TRANSLATING \Klang{} to SMT-LIB}
\label{sec:k2smt}



\lstset{language=SMT,numbers=none}

\begin{center}
\begin{tabular}{c}
\small
\begin{lstlisting}
(declare-datatypes () ((Thing 
  (mk-Thing (weight Int)))))
\end{lstlisting}
\end{tabular}
\end{center}


\lstset{language=K,numbers=none}

\begin{center}
\begin{tabular}{c}
\small
\begin{lstlisting}
class A {     class B {
  b : B         a : A
}             }
\end{lstlisting}
\end{tabular}
\end{center}





\begin{center}
\begin{tabular}{c}
\small
\begin{lstlisting}  
(declare-datatypes () ((SpaceCraft 
  (mk-SpaceCraft 
      (weight Int)
      (instrWeight Real)
      (radio Ref) (camera Ref)
      (software Ref)))))
\end{lstlisting}
\end{tabular}
\end{center}

\noindent Observe how the fact that \code{SpaceCraft} inherits from
\code{Thing} is modeled by the inclusion of the \code{weight} field
from \code{Thing}. Inheritance is simply modeled by property
inclusion in this manner.  In order to define a heap, we need a
datatype that represents all the objects that can possibly be stored
in the heap. The following datatype \code{Any} represents all the
datatypes for the individual classes, by lifting them to this single
type (\code{null} is a zero argument constructor). The type \code{Any}
corresponds to Java's type \code{Object}.

\begin{center}
\begin{tabular}{c}
\small
\begin{lstlisting}
(declare-datatypes () ((Any
  (lift-Thing 
    (sel-Thing Thing))
  (lift-Instr 
    (sel-Instr Instr))
  (lift-SpaceCraft 
    (sel-SpaceCraft SpaceCraft))
  ...
  null)))
\end{lstlisting}
\end{tabular}
\end{center}

\noindent Now we can define the heap as an array from references of
type \code{Ref} to \code{Any}.

\begin{center}
\begin{tabular}{c}
\small
\begin{lstlisting}
(declare-const heap (Array Ref Any))
\end{lstlisting}
\end{tabular}
\end{center}

\textbf{Accessing the heap} We first define a function \code{deref},
which when applied to a reference returns the \code{Any} object at
that entry.

\begin{center}
\begin{tabular}{c}
\small
\begin{lstlisting}
(define-fun deref ((ref Ref)) Any
  (select heap ref))
\end{lstlisting}
\end{tabular}
\end{center}

\noindent With this function we are now ready to define functions,
which can test what kind of object is at a certain location in the
heap, as well as retrieve that object. The following functions perform
these two tasks for the case of the \code{Instr} objects (for
each datatype constructor \code{C}, SMT-LIB generates an \code{is-C}
function that can determine whether an object is constructed with the
constructor).

\begin{center}
\begin{tabular}{c}
\small
\begin{lstlisting}
(define-fun deref-is-Instr 
  ((this Ref)) Bool
  (is-lift-Instr (deref this)))

(define-fun deref-Instr 
  ((this Ref)) Instr
  (sel-Instr (deref this)))
\end{lstlisting}
\end{tabular}
\end{center}

\noindent As we have seen, K classes can contain properties of types
that are classes. For example the \code{SpaceCraft} class contains a
property \code{radio} of type \code{Instr}. In an object-oriented
language like K with inheritance, such a property can denote any
object that is of type that either is equal to, or sub-classes
\code{Instr}. In order to formulate invariants on objects of
class \code{SpaceCraft}, we therefore need to be able to determine
whether a \code{radio} object is equal to, or sub-classes
\code{Instr}. This task is performed by the following function,
the body of which is a disjunction between the three alternatives.

\begin{center}
\begin{tabular}{c}
\small
\begin{lstlisting}
(define-fun deref-isa-Instr 
  ((this Ref)) Bool
  (or
    (deref-is-Instr this)
    (deref-is-SmplRadio this)
    (deref-is-SmrtRadio this)))
\end{lstlisting}
\end{tabular}
\end{center}

\textbf{Getters of properties in classes} Functions and requirements
access properties. An example is the expression \code{weight > 0} in
class \code{Instr}.  These accesses are wrapped into {\em getter}
functions. As an example, the \code{weight} property of the class
\code{Instr} can be accessed with a call of the following
function, named \code{Instr!weight} (SMT-LIB allows symbols such
as `\code{!}'  in names, to be discussed further below), on a
reference that is assumed to refer to an \code{Instr} object.

\begin{center}
\begin{tabular}{c}
\small
\begin{lstlisting}
(define-fun Instr!weight 
  ((this Ref)) Int
  (weight (deref-Instr this)))
\end{lstlisting}
\end{tabular}
\end{center}

\noindent The above definition assumes that the \code{this} reference
denotes an \code{Instr} object, and not an object of any
sub-class on \code{Instr}, hence the `\code{!}' symbol (for {\em
  exact!  class}) in the name.  This is sufficient when checking
satisfiability of the class \code{Instr} class itself. However,
when checking the satisfiability of, for example, the
\code{SpaceCraft} class, which {\em contains} a property of type
\code{Instr}, as for example \code{radio : Instr}, we have
to assume that \code{radio} in addition potentially can refer to any
object of a class that sub-classes \code{Instr}, which in this
case is either \code{SmplRadio} or \code{SmrtRadio}. This is
achieved with the following alternative getter function, named
\code{Instr.weight}, for the \code{weight} property of the class
\code{Instr}.

\begin{center}
\small
\begin{lstlisting}
(define-fun Instr.weight 
  ((this Ref)) Int
  ; if
  (ite (deref-is-Instr this)         
    ; then
    (weight (deref-Instr this))      
    ; else if
    (ite (deref-is-SmplRadio this)      
      ; then
      (weight (deref-SmplRadio this))   
      ; else
      (weight (deref-SmrtRadio this))
    )))
\end{lstlisting}
\end{center}

\noindent Each line in the body is preceded with a comment using the
comment symbol `\code{;}', explaining the structure of the LISP
version of `${\bf if}\ e_1\ {\bf then}\ e_2\ {\bf else}\ e_3$', which
is `$({\bf ite}\ e_1\ e_2\ e_3)$'. The reason for not just using the
latter more general function \code{Instrument.weight} for all accesses
to the \code{weight} property is that conditionals make it harder for
an SMT solver. Even moderately sized expressions with several accesses
to variables become unsolvable in reasonable time in the presence of
such conditional expressions.

\textbf{Functions} Functions are translated directly to SMT-LIB
functions.  Each function is translated in two versions, corresponding
to the two versions of the getter functions, and named using
respectively \code{className!functionName} and
\code{className.functionName}, to suggest which getter functions are
called inside the function, again depending on the calling context
(whether \code{this} refers to the exact class or potentially a
sub-class). As an example, the following is the translation of the
\code{after} function in the class \code{Event}, only showing one of
the two versions, which are the same in this case.

\begin{center}
\begin{tabular}{c}
\small
\begin{lstlisting}
(define-fun Event.after 
  ((this Ref)(e Ref)) Bool
  (>= (Event.start this)  
  (Event.end e)))
\end{lstlisting}
\end{tabular}
\end{center}

\noindent The first parameter is a reference (named \code{this}) of
type \code{Ref}. The \code{this} reference is meant to refer to the
object upon which the function is called. Consider for example a call
like: \code{tkPic.after(initMem)} in line 31 of Figure
\ref{fig:spacecraftSmt}. Here \code{tkPic} denotes a reference
to which the parameter \code{this} is bound.  The second parameter is
the user-provided parameter.

%\subsection{Invariants and assertions}

\textbf{Invariants and assertions} We are finally able to present how
class invariants are generated and asserted. These validate the
satisfiability of our classes.  The invariant for a class is generated
as a function that as argument takes a \code{this} reference to an
object of that class. Let's take the example of the
\code{SysMngr} class. The generated invariant is the following.

\begin{center}
\begin{tabular}{c}
\small
\begin{lstlisting}
(define-fun SysMngr.inv 
  ((this Ref)) Bool
  (and
    (deref-isa-Event 
      (SysMngr!bootUp this))
    (deref-isa-Event 
      (SysMngr!initMem this))
    (deref-isa-Event 
      (SysMngr!tkPic this))
    (and 
      (Event.after 
        (SysMngr!tkPic this)  
        (SysMngr!initMem this)) 
      (Event.after 
        (SysMngr!tkPic this)  
        (SysMngr!bootUp this)))))
\end{lstlisting}
\end{tabular}
\end{center}

\noindent The body of this function is a conjunction of the conditions
that have to hold on the \code{SysMngr} object referred to by
\code{this}. There are four such: three for the property definitions
in lines 28 -- 30 in Figure \ref{fig:spacecraftSmt}, and one for the
requirement on line 31. Each of the property definitions results in a
condition that verifies that the property is of the right type, in
these three cases: that each of the properties \code{bootUp},
\code{initMem}, and \code{tkPic}, are objects of any sub-class of
class \code{Event} (the use of `\code{isa}'), although in this case
there are no sub-classes of \code{Event}. The last condition,
corresponding to the requirement, illustrates how functions are called,
in the case the function \code{after}.

We are now finally ready to assert the well-formedness of the
model. For each class two assertions are generated, one that asserts
the existence of an object of the class in the heap, and one asserting
that every object of that class in the heap satisfies the invariant of
that class. Below are these two assertions for the \code{SysMngr}
class.

\begin{center}
\begin{tabular}{c}
\small
\begin{lstlisting}
(assert (exists ((this Ref)) 
  (deref-is-SysMngr this)))

(assert (forall ((this Ref))
  (=> 
    (deref-is-SysMngr this) 
    (SysMngr.inv this))))
\end{lstlisting}
\end{tabular}
\end{center}

\textbf{Solving the model} Given the generated SMT-LIB model outlined
above, an SMT solver following the SMT-LIB standard can determine
whether the model is satisfiable. Our currently used SMT solver is
Z3. If the model is {\bf not} satisfiable, the solver will just return
`not satisfied'. One can in this case analyze subsets of the model,
eliminating assertions to discover which assertions caused the model
to become unsatisfiable, in the best case the minimal set of such
assertions. We are working on such a violation explanation capability.


If the model on the other hand is satisfiable, an assignment to
variables in the model will be returned by the solver. In our case the
model outlined above is satisfiable and solves in 2 seconds.  The
returned assignment is shown in Figure \ref{fig:shapes}. This view has
been produced by processing the output from Z3, which is less
comprehensible.
%
The assignment shows the following. The outermost \code{ShRaan}
property in the heap denotes a \code{SpaceCraft} object.  This object
contains various fields, for example the \code{weight} property with
the value $18$, and the \code{software} property, which denotes the
reference (of type \code{Ref}) $21$. This reference in turn denotes a
\code{SysMngr} object containing three references \code{bootUp}
($25$), \code{initMem} ($26$), and \code{tkPic} ($27$), each of
which are events. Due to the constraint in line 31 of Figure
\ref{fig:spacecraftSmt} these events have been {\em scheduled} such
that the taking of the picture occurs after the boot as well as after
the memory initialization.  This can be seen from the fact that the
end times of the boot and memory initialization events at references
$25$ and $26$ are less than the start time of the take picture event
at reference $27$. Note that the values suggested by the SMT solver 
are not necessarily realistic, although they satisfy the provided
constraints.

\lstset{language=K}
