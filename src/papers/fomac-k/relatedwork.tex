
\section{Related Work}
\label{sec:related-work}

\Klang{} is intended to represent a textual modeling language capable
of representing \sysml{} concepts, specifically class diagrams with
constraints.  However, as mentioned in the introduction, it also
contains programming constructs.  As such it can be perceived as a
wide-spectrum modeling/programming language.

Wide spectrum specification languages have been investigated to length
in the formal methods community. One of the well-known examples
is \vdm{} \cite{vdm78,bjoerner-jones-82,jones90,jones-shaw-90}. \vdm{}
in its original form \cite{vdm78} provided a combination of procedural
programming and functional programming and specification using sets,
lists and maps (with proper mathematical notation), and higher-order
predicate logic. \vdmpp{} \cite{vdmplusplus05} added
object-orientation to \vdm{}, which is now part of the \vdm{}
standard. The \raiselang{} specification language (\rsl{})
\cite{raise92} is a wide-spectrum language taking inspiration from
\vdm{} as well as from other modeling languages such as \zlang{}
\cite{spivey-Z-1988}, and from algebraic equational specification
languages. Here refinement is the simpler theory implication: the implementation
shall imply the specification in a logic sense. \asml{} \cite{asml05} is a 
more recent wide-spectrum specification language, in many ways similar to \vdm{}, 
but based on the fundamental concept that operations operate on algebras. 
Other fundamental works on refinement include (not a comprehensive list): \cite{wirth-refinement-71,hoare-sanders-refinement-86,morgan-refinement-94,woodcock-sanders-z-96,back-wright-refinement-98,abrial-eventb-10}.

\alloy{} \cite{jackson-alloy-12} added new life to this community by being 
supported by a SAT solver. In many respects, \Klang{} is close in spirit 
to \alloy{}, but differs by being supported by an SMT solver (in contrast to
a SAT solver), resulting in a richer set of constructs, including arithmetic, 
being exposed to analysis. \Klang{} also combines a type view as found in 
traditional specification and programming languages, as well as a relational 
view, whereas \alloy{} is purely relational. We are of the belief that the notion
of a type is fundamental to programming as well as to modeling.

Several high-level programming languages have been developed in recent
years, including the early \sml{} (Standard ML) \cite{standard-ml-97},
its derivative \ocaml{} \cite{ocaml}, and \haskell{}
\cite{haskell}. However, also \java{} can be considered high-level due
to its libraries of collections (sets, lists, and maps), as well as
the iterator concept. \python{} \cite{python} is close to combining
object-oriented and functional programming. The \scala{} \cite{scala}
language does this to the full extent, as does the \fortress{}
\cite{fortress}. The close relationship between \scala{} and \vdm{} is discussed in
\cite{havelund-scala-vdm-12}.

Specification constructs have been introduced in programming
languages, in the form of design-by-contract (pre/post conditions +
class invariants). Examples are \eiffel{} \cite{eiffel} and
\specsharp{} \cite{specsharp}, where contracts are part of the
language. \scala{} has library functions for writing pre/post
conditions on functional programs \cite{odersky-rv10}. Finally, The
\jml{} language \cite{jml} allows to write design-by-contract
specifications for \java{} as comments. These are ignored by the
standard \java{} compiler, and therefore must be processed with
special tools. \eml{} (Extended ML) \cite{sannella-eml-97} takes a
slightly different approach to specification and formal development of
\sml{} programs.  \eml{} specifications look just like \sml{} programs
except that axioms are allowed in signatures and in place of code in
structures and functors. Some \eml{} specifications are executable,
since \sml{} function definitions are just axioms of a certain special
form. This makes \eml{} a wide-spectrum language which can be used to
express every stage in the development of a \sml{} program from the
initial high-level specification to the final program itself and
including intermediate stages in which specification and program are
intermingled.

Apart from all the work in the language domain, performing analysis
and verification of languages has also seen great
strides.~\cite{holzmann-spin-2004} performs model checking of models
expressed in Promela and Java
PathFinder~\cite{havelund-jpf-00,havelund-visser02} performs model
checking of Java programs. The latter can be used not only for
expressing models in Java and verifying them, but also for proving
program properties.~\cite{ball2010slam2} presents results of applying
static analysis and counter-example guided abstraction refinement to
device drivers in a large scale industry setting. 

The great improvements in model checking, static analysis, theorem
proving, and SMT solvers such as Z3~\cite{de2008z3} have all
contributed to investigating and dealing with software change. To this
effect, differential symbolic execution~\cite{person2008differential}
has been investigated for establishing equivalence between two
versions of a program.~\cite{lahiri2012symdiff} uses verification
conditions and SMT solvers for detecting semantic change between two
closely related versions of a function (program) by discovering inputs
to a function that cause the outputs to
change.~\cite{godlin2009regression} deals with \emph{regression
  verification} and present a technique for doing equivalence checking
of C programs, by using the older version of the program almost as a
\emph{specification} for the new version of the program. A large part
of the inspiration for such work comes from the theorem proving
community.



